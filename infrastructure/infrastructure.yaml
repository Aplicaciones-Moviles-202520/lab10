AWSTemplateFormatVersion: '2010-09-09'
Description: 'Spaceships Sightings Processing System'

Parameters:

  DeploymentType:
    Type: String
    AllowedValues: ['dev', 'prod']
    Default: 'dev'
    Description: 'Deployment type: dev allows CORS for any origin, prod restricts CORS to the configured domain.'

  CustomDomainName:
    Type: String
    Default: '12345678k.www.exampledomain.cloud'
    Description: 'Custom domain name for CloudFront distribution (optional). Leave empty to use CloudFront domain.'
  
  SSLCertificateId:
    Type: String
    Default: 'XXXXXXXX-XXXX-XXXX-XXXX-XXXXXXXXXXXX'
    Description: 'ID of the SSL certificate in us-east-1 for the custom domain (required if CustomDomainName is provided). Just the certificate ID, not the full ARN.'
  
  JWTSecret:
    Type: String
    NoEcho: true
    MinLength: 32
    Description: 'Secret key for JWT token signing. Must be at least 32 characters long. Keep this secure!'
    Default: 'mi-secreto-super-seguro-2025-cambiar-al-desplegar'

Rules:

  ProdRequiresCustomDomain:
    RuleCondition: !Equals [!Ref DeploymentType, 'prod']
    Assertions:
      - Assert: !Not [!Equals [!Ref CustomDomainName, '']]
        AssertDescription: 'In prod, CustomDomainName must be provided.'
      - Assert: !Not [!Equals [!Ref SSLCertificateId, '']]
        AssertDescription: 'In prod, SSLCertificateId must be provided.'

Conditions:

  HasCustomDomain: !Not [!Equals [!Ref CustomDomainName, '']]
  HasSSLCertificate: !Not [!Equals [!Ref SSLCertificateId, '']]
  UseCustomDomainConfig: !And [!Condition HasCustomDomain, !Condition HasSSLCertificate]
  IsDev: !Equals [!Ref DeploymentType, 'dev']
  IsProd: !Equals [!Ref DeploymentType, 'prod']

Resources:

  #################################################################################
  # Persistence ###################################################################
  #################################################################################

  # Tables ########################################################################

  # Users table for authentication
  SpaceshipsTableUsers:
    Type: AWS::DynamoDB::Table
    Properties:
      BillingMode: PAY_PER_REQUEST
      AttributeDefinitions:
        - AttributeName: username
          AttributeType: S
      KeySchema:
        - AttributeName: username
          KeyType: HASH

  # Spaceship registry table
  SpaceshipsTableRegistry:
    Type: AWS::DynamoDB::Table
    Properties:
      BillingMode: PAY_PER_REQUEST
      AttributeDefinitions:
        - AttributeName: spaceship_id
          AttributeType: S
      KeySchema:
        - AttributeName: spaceship_id
          KeyType: HASH

  # Buckets #######################################################################

  # S3 Bucket for static website
  SpaceshipsBucketWebsite:
    Type: AWS::S3::Bucket
    Properties:
      PublicAccessBlockConfiguration:
        BlockPublicAcls: true
        BlockPublicPolicy: true
        IgnorePublicAcls: true
        RestrictPublicBuckets: true
      BucketEncryption:
        ServerSideEncryptionConfiguration:
          - ServerSideEncryptionByDefault:
              SSEAlgorithm: AES256

  SpaceshipsBucketPolicyWebsite:
    Type: AWS::S3::BucketPolicy
    Properties:
      Bucket: !Ref SpaceshipsBucketWebsite
      PolicyDocument:
        Statement:
          - Sid: AllowCloudFrontAccess
            Effect: Allow
            Principal:
              Service: cloudfront.amazonaws.com
            Action: 's3:GetObject'
            Resource: !Sub '${SpaceshipsBucketWebsite.Arn}/*'

  #################################################################################
  # Lambda Functions ##############################################################
  #################################################################################

  # Login #########################################################################

  SpaceshipsLambdaExecutionRoleLogin:
    Type: AWS::IAM::Role
    Properties:
      AssumeRolePolicyDocument:
        Version: '2012-10-17'
        Statement:
          - Effect: Allow
            Principal:
              Service: lambda.amazonaws.com
            Action: sts:AssumeRole
      ManagedPolicyArns:
        - arn:aws:iam::aws:policy/service-role/AWSLambdaBasicExecutionRole
      Policies:
        - PolicyName: DynamoDBAccess
          PolicyDocument:
            Version: '2012-10-17'
            Statement:
              - Effect: Allow
                Action:
                  - dynamodb:GetItem
                Resource: !GetAtt SpaceshipsTableUsers.Arn

  SpaceshipsLambdaLogin:
    Type: AWS::Lambda::Function
    Properties:
      Runtime: python3.13
      Handler: index.lambda_handler
      Role: !GetAtt SpaceshipsLambdaExecutionRoleLogin.Arn
      Code:
        ZipFile: |
          import json
          import boto3
          import os

          def lambda_handler(event, context):
              # Debug: Imprimir el evento recibido
              print(f"Evento recibido: {json.dumps(event)}")
              
              try:
                  # Extraer username y password del body del evento
                  if not event.get('body'):
                      return {
                          'statusCode': 400,
                          'headers': {
                              'Content-Type': 'application/json',
                              'Access-Control-Allow-Origin': os.environ.get('ALLOWED_ORIGIN', '*')
                          },
                          'body': json.dumps({'error': 'Body requerido'})
                      }
                  
                  body = json.loads(event['body'])
                  username = body.get('username')
                  password = body.get('password')
                  
                  # Validar que ambos campos estén presentes
                  if not username or not password:
                      return {
                          'statusCode': 400,
                          'headers': {
                              'Content-Type': 'application/json',
                              'Access-Control-Allow-Origin': os.environ.get('ALLOWED_ORIGIN', '*')
                          },
                          'body': json.dumps({'error': 'Username y password son requeridos'})
                      }
                  
                  # Conectar a DynamoDB y buscar el usuario
                  dynamodb = boto3.resource('dynamodb')
                  table = dynamodb.Table(os.environ['USERS_TABLE'])
                  
                  response = table.get_item(Key={'username': username})
                  
                  # Verificar si el usuario existe
                  if 'Item' not in response:
                      return {
                          'statusCode': 401,
                          'headers': {
                              'Content-Type': 'application/json',
                              'Access-Control-Allow-Origin': os.environ.get('ALLOWED_ORIGIN', '*')
                          },
                          'body': json.dumps({'error': 'Credenciales inválidas'})
                      }
                  
                  user = response['Item']
                  
                  # Validar las credenciales
                  # Comparar la password del usuario con la almacenada en DynamoDB
                  if user.get('password') != password:
                      return {
                          'statusCode': 401,
                          'headers': {
                              'Content-Type': 'application/json',
                              'Access-Control-Allow-Origin': os.environ.get('ALLOWED_ORIGIN', '*')
                          },
                          'body': json.dumps({'error': 'Credenciales inválidas'})
                      }
                  
                  # Obtener rol del usuario (por defecto "reporter")
                  user_role = user.get('role', 'reporter')
                  
                  # Si las credenciales son válidas, crear y retornar JWT token
                  token = create_jwt_token(username, user_role)
                  
                  return {
                      'statusCode': 200,
                      'headers': {
                          'Content-Type': 'application/json',
                          'Access-Control-Allow-Origin': os.environ.get('ALLOWED_ORIGIN', '*')
                      },
                      'body': json.dumps({
                          'message': 'Login exitoso',
                          'token': token,
                          'username': username,
                          'role': user_role
                      })
                  }
                  
              except Exception as e:
                  print(f"Error en lambda_handler: {str(e)}")
                  return {
                      'statusCode': 500,
                      'headers': {
                          'Content-Type': 'application/json',
                          'Access-Control-Allow-Origin': os.environ.get('ALLOWED_ORIGIN', '*')
                      },
                      'body': json.dumps({'error': f'Error interno: {str(e)}'})
                  }

          def create_jwt_token(username, role='reporter'):
              """
              Función auxiliar para crear tokens JWT con información de rol.
              """
              import base64
              import json
              import hmac
              import hashlib
              from datetime import datetime, timedelta

              # Header
              header = {
                  "alg": "HS256",
                  "typ": "JWT"
              }

              # Payload
              payload = {
                  "sub": username,
                  "role": role,
                  "iat": int(datetime.utcnow().timestamp()),
                  "exp": int((datetime.utcnow() + timedelta(hours=24)).timestamp()),
                  "iss": "spaceship-registry"
              }

              # Codificar header y payload
              header_encoded = base64.urlsafe_b64encode(json.dumps(header).encode()).decode().rstrip('=')
              payload_encoded = base64.urlsafe_b64encode(json.dumps(payload).encode()).decode().rstrip('=')

              # Crear signature
              message = f"{header_encoded}.{payload_encoded}"
              secret = os.environ['JWT_SECRET'].encode()
              signature = hmac.new(secret, message.encode(), hashlib.sha256).digest()
              signature_encoded = base64.urlsafe_b64encode(signature).decode().rstrip('=')

              return f"{header_encoded}.{payload_encoded}.{signature_encoded}"
      Environment:
        Variables:
          USERS_TABLE: !Ref SpaceshipsTableUsers
          JWT_SECRET: !Ref JWTSecret
          ALLOWED_ORIGIN: !If [IsDev, '*', !Sub 'https://${CustomDomainName}']
  
  SpaceshipsLambdaPermissionLogin:
    Type: AWS::Lambda::Permission
    Properties:
      Action: lambda:InvokeFunction
      FunctionName: !Ref SpaceshipsLambdaLogin
      Principal: apigateway.amazonaws.com
      SourceArn: !Sub arn:aws:execute-api:${AWS::Region}:${AWS::AccountId}:${SpaceshipsApi}/*/POST/api/login

  # POST Spaceships ###############################################################

  SpaceshipsLambdaExecutionRolePost:
    Type: AWS::IAM::Role
    Properties:
      AssumeRolePolicyDocument:
        Version: '2012-10-17'
        Statement:
          - Effect: Allow
            Principal:
              Service: lambda.amazonaws.com
            Action: sts:AssumeRole
      ManagedPolicyArns:
        - arn:aws:iam::aws:policy/service-role/AWSLambdaBasicExecutionRole
      Policies:
        - PolicyName: DynamoDBWriteAccess
          PolicyDocument:
            Version: '2012-10-17'
            Statement:
              - Effect: Allow
                Action:
                  - dynamodb:PutItem
                Resource: !GetAtt SpaceshipsTableRegistry.Arn

  SpaceshipsLambdaPost:
    Type: AWS::Lambda::Function
    Properties:
      Runtime: python3.13
      Handler: index.lambda_handler
      Role: !GetAtt SpaceshipsLambdaExecutionRolePost.Arn
      Code:
        ZipFile: |
          import json
          import boto3
          import os

          def lambda_handler(event, context):
              # Conectar a DynamoDB
              dynamodb = boto3.resource('dynamodb')
              table = dynamodb.Table(os.environ['REGISTRY_TABLE'])

              try:
                  # Obtener datos del body
                  body = json.loads(event['body'])

                  # Validar campos requeridos
                  if not all(field in body for field in ['spaceship_id', 'model', 'pilot']):
                      return {
                          'statusCode': 400,
                          'headers': {
                              'Content-Type': 'application/json',
                              'Access-Control-Allow-Origin': os.environ.get('ALLOWED_ORIGIN', '*')
                          },
                          'body': json.dumps({'error': 'Campos requeridos: spaceship_id, model, pilot'})
                      }

                  # Crear item para DynamoDB (solo los campos especificados)
                  item = {
                      'spaceship_id': body['spaceship_id'],
                      'model': body['model'],
                      'pilot': body['pilot']
                  }

                  # Guardar en DynamoDB
                  table.put_item(Item=item)

                  return {
                      'statusCode': 201,
                      'headers': {
                          'Content-Type': 'application/json',
                          'Access-Control-Allow-Origin': os.environ.get('ALLOWED_ORIGIN', '*')
                      },
                      'body': json.dumps({'message': 'Nave registrada exitosamente', 'spaceship': item})
                  }

              except json.JSONDecodeError:
                  return {
                      'statusCode': 400,
                      'headers': {
                          'Content-Type': 'application/json',
                          'Access-Control-Allow-Origin': os.environ.get('ALLOWED_ORIGIN', '*')
                      },
                      'body': json.dumps({'error': 'JSON inválido'})
                  }
              except Exception as e:
                  print(f"Error: {str(e)}")
                  return {
                      'statusCode': 500,
                      'headers': {
                          'Content-Type': 'application/json',
                          'Access-Control-Allow-Origin': os.environ.get('ALLOWED_ORIGIN', '*')
                      },
                      'body': json.dumps({'error': 'Error interno del servidor'})
                  }
      Environment:
        Variables:
          REGISTRY_TABLE: !Ref SpaceshipsTableRegistry
          ALLOWED_ORIGIN: !If [IsDev, '*', !Sub 'https://${CustomDomainName}']

  SpaceshipsLambdaPermissionPost:
    Type: AWS::Lambda::Permission
    Properties:
      Action: lambda:InvokeFunction
      FunctionName: !Ref SpaceshipsLambdaPost
      Principal: apigateway.amazonaws.com
      SourceArn: !Sub arn:aws:execute-api:${AWS::Region}:${AWS::AccountId}:${SpaceshipsApi}/*/POST/api/spaceships

  # GET Spaceships ################################################################

  SpaceshipsLambdaExecutionRoleGet:
    Type: AWS::IAM::Role
    Properties:
      AssumeRolePolicyDocument:
        Version: '2012-10-17'
        Statement:
          - Effect: Allow
            Principal:
              Service: lambda.amazonaws.com
            Action: sts:AssumeRole
      ManagedPolicyArns:
        - arn:aws:iam::aws:policy/service-role/AWSLambdaBasicExecutionRole
      Policies:
        - PolicyName: DynamoDBReadAccess
          PolicyDocument:
            Version: '2012-10-17'
            Statement:
              - Effect: Allow
                Action:
                  - dynamodb:GetItem
                  - dynamodb:Scan
                Resource: !GetAtt SpaceshipsTableRegistry.Arn

  SpaceshipsLambdaGet:
    Type: AWS::Lambda::Function
    Properties:
      Runtime: python3.13
      Handler: index.lambda_handler
      Role: !GetAtt SpaceshipsLambdaExecutionRoleGet.Arn
      Code:
        ZipFile: |
          import json
          import boto3
          import os

          def lambda_handler(event, context):
              # Conectar a DynamoDB
              dynamodb = boto3.resource('dynamodb')
              table = dynamodb.Table(os.environ['REGISTRY_TABLE'])

              # Obtener el ID de la nave si se proporciona
              spaceship_id = event.get('pathParameters', {}).get('id') if event.get('pathParameters') else None

              try:
                  if spaceship_id:
                      # Obtener una nave específica
                      response = table.get_item(Key={'spaceship_id': spaceship_id})
                      if 'Item' in response:
                          return {
                              'statusCode': 200,
                              'headers': {
                                  'Content-Type': 'application/json',
                                  'Access-Control-Allow-Origin': os.environ.get('ALLOWED_ORIGIN', '*')
                              },
                              'body': json.dumps(dict(response['Item']))
                          }
                      else:
                          return {
                              'statusCode': 404,
                              'headers': {
                                  'Content-Type': 'application/json',
                                  'Access-Control-Allow-Origin': os.environ.get('ALLOWED_ORIGIN', '*')
                              },
                              'body': json.dumps({'error': 'Nave no encontrada'})
                          }
                  else:
                      # Obtener todas las naves
                      response = table.scan()
                      items = response.get('Items', [])
                      return {
                          'statusCode': 200,
                          'headers': {
                              'Content-Type': 'application/json',
                              'Access-Control-Allow-Origin': os.environ.get('ALLOWED_ORIGIN', '*')
                          },
                          'body': json.dumps([dict(item) for item in items])
                      }
              except Exception as e:
                  print(f"Error: {str(e)}")
                  return {
                      'statusCode': 500,
                      'headers': {
                          'Content-Type': 'application/json',
                          'Access-Control-Allow-Origin': os.environ.get('ALLOWED_ORIGIN', '*')
                      },
                      'body': json.dumps({'error': 'Error interno del servidor'})
                  }
      Environment:
        Variables:
          REGISTRY_TABLE: !Ref SpaceshipsTableRegistry
          ALLOWED_ORIGIN: !If [IsDev, '*', !Sub 'https://${CustomDomainName}']

  SpaceshipsLambdaPermissionRegistryGet:
    Type: AWS::Lambda::Permission
    Properties:
      Action: lambda:InvokeFunction
      FunctionName: !Ref SpaceshipsLambdaGet
      Principal: apigateway.amazonaws.com
      SourceArn: !Sub arn:aws:execute-api:${AWS::Region}:${AWS::AccountId}:${SpaceshipsApi}/*/GET/api/spaceships

  SpaceshipsLambdaPermissionRegistryGetById:
    Type: AWS::Lambda::Permission
    Properties:
      Action: lambda:InvokeFunction
      FunctionName: !Ref SpaceshipsLambdaGet
      Principal: apigateway.amazonaws.com
      SourceArn: !Sub arn:aws:execute-api:${AWS::Region}:${AWS::AccountId}:${SpaceshipsApi}/*/GET/api/spaceships/*

  #################################################################################
  # API ###########################################################################
  #################################################################################

  # Authorizer ####################################################################

  SpaceshipsLambdaExecutionRoleAuthorizer:
    Type: AWS::IAM::Role
    Properties:
      AssumeRolePolicyDocument:
        Version: '2012-10-17'
        Statement:
          - Effect: Allow
            Principal:
              Service: lambda.amazonaws.com
            Action: sts:AssumeRole
      ManagedPolicyArns:
        - arn:aws:iam::aws:policy/service-role/AWSLambdaBasicExecutionRole

  SpaceshipsLambdaAuthorizer:
    Type: AWS::Lambda::Function
    Properties:
      Runtime: python3.13
      Handler: index.lambda_handler
      Role: !GetAtt SpaceshipsLambdaExecutionRoleAuthorizer.Arn
      Code:
        ZipFile: |
          import json
          import base64
          import hmac
          import hashlib
          import os
          from datetime import datetime

          def lambda_handler(event, context):
              try:
                  # Extraer token del header Authorization
                  token = event['headers'].get('authorization', '').replace('Bearer ', '')
                  
                  if not token:
                      raise Exception('No token provided')

                  # Validar JWT token
                  is_valid, payload = validate_jwt_token(token)
                  
                  if not is_valid:
                      raise Exception('Invalid token')

                  # Crear policy de autorización
                  policy = generate_policy(payload['sub'], 'Allow', event['routeArn'])
                  
                  # Agregar context con información del usuario
                  policy['context'] = {
                      'username': payload['sub'],
                      'role': payload.get('role', 'reporter'),
                      'tokenExp': str(payload.get('exp', ''))
                  }
                  
                  return policy

              except Exception as e:
                  print(f"Authorization failed: {str(e)}")
                  # Retornar policy de denegación
                  return generate_policy('user', 'Deny', event['routeArn'])

          def validate_jwt_token(token):
              try:
                  # Dividir el token en sus partes
                  parts = token.split('.')
                  if len(parts) != 3:
                      return False, None

                  header_encoded, payload_encoded, signature_encoded = parts

                  # Decodificar payload
                  payload_decoded = base64.urlsafe_b64decode(payload_encoded + '==')
                  payload = json.loads(payload_decoded)

                  # Verificar expiración
                  if payload.get('exp', 0) < datetime.utcnow().timestamp():
                      return False, None

                  # Verificar signature
                  message = f"{header_encoded}.{payload_encoded}"
                  secret = os.environ['JWT_SECRET'].encode()
                  expected_signature = hmac.new(secret, message.encode(), hashlib.sha256).digest()
                  expected_signature_encoded = base64.urlsafe_b64encode(expected_signature).decode().rstrip('=')

                  if signature_encoded != expected_signature_encoded:
                      return False, None

                  return True, payload

              except Exception as e:
                  print(f"Token validation error: {str(e)}")
                  return False, None

          def generate_policy(principal_id, effect, resource):
              policy = {
                  'principalId': principal_id,
                  'policyDocument': {
                      'Version': '2012-10-17',
                      'Statement': [
                          {
                              'Action': 'execute-api:Invoke',
                              'Effect': effect,
                              'Resource': resource
                          }
                      ]
                  }
              }
              return policy
      Environment:
        Variables:
          JWT_SECRET: !Ref JWTSecret

  SpaceshipsLambdaAuthorizerPermission:
    Type: AWS::Lambda::Permission
    Properties:
      Action: lambda:InvokeFunction
      FunctionName: !Ref SpaceshipsLambdaAuthorizer
      Principal: apigateway.amazonaws.com
      SourceArn: !Sub arn:aws:execute-api:${AWS::Region}:${AWS::AccountId}:${SpaceshipsApi}/authorizers/${SpaceshipsApiAuthorizer}

  # API Gateway ###################################################################

  SpaceshipsApi:
    Type: AWS::ApiGatewayV2::Api
    Properties:
      Name: !Sub "${AWS::StackName}-Api"
      ProtocolType: HTTP
      CorsConfiguration:
        AllowOrigins: !If
          - IsDev
          - ['*']
          - [!Sub 'https://${CustomDomainName}']
        AllowMethods: ['GET', 'POST', 'OPTIONS']
        AllowHeaders: ['*', 'Authorization']

  SpaceshipsApiStage:
    Type: AWS::ApiGatewayV2::Stage
    Properties:
      ApiId: !Ref SpaceshipsApi
      StageName: $default
      AutoDeploy: true
      Description: Default stage with auto-deploy

  SpaceshipsApiAuthorizer:
    Type: AWS::ApiGatewayV2::Authorizer
    Properties:
      Name: !Sub "${AWS::StackName}-Api-Authorizer"
      ApiId: !Ref SpaceshipsApi
      AuthorizerType: REQUEST
      AuthorizerUri: !Sub arn:aws:apigateway:${AWS::Region}:lambda:path/2015-03-31/functions/${SpaceshipsLambdaAuthorizer.Arn}/invocations
      AuthorizerPayloadFormatVersion: '2.0'
      EnableSimpleResponses: false

  # Integrations ##################################################################

  SpaceshipsApiIntegrationLogin:
    Type: AWS::ApiGatewayV2::Integration
    Properties:
      ApiId: !Ref SpaceshipsApi
      IntegrationType: AWS_PROXY
      IntegrationUri: !Sub arn:aws:lambda:${AWS::Region}:${AWS::AccountId}:function:${SpaceshipsLambdaLogin}
      PayloadFormatVersion: "2.0"

  LoginRoute:
    Type: AWS::ApiGatewayV2::Route
    Properties:
      ApiId: !Ref SpaceshipsApi
      RouteKey: POST /api/login
      Target: !Sub integrations/${SpaceshipsApiIntegrationLogin}
    DependsOn: SpaceshipsApiIntegrationLogin

  SpaceshipsApiIntegrationPost:
    Type: AWS::ApiGatewayV2::Integration
    Properties:
      ApiId: !Ref SpaceshipsApi
      IntegrationType: AWS_PROXY
      IntegrationUri: !Sub arn:aws:lambda:${AWS::Region}:${AWS::AccountId}:function:${SpaceshipsLambdaPost}
      PayloadFormatVersion: "2.0"

  SpaceshipsApiRoutePost:
    Type: AWS::ApiGatewayV2::Route
    Properties:
      ApiId: !Ref SpaceshipsApi
      RouteKey: POST /api/spaceships
      Target: !Sub integrations/${SpaceshipsApiIntegrationPost}
    DependsOn: SpaceshipsApiIntegrationPost

  SpaceshipsApiIntegrationGet:
    Type: AWS::ApiGatewayV2::Integration
    Properties:
      ApiId: !Ref SpaceshipsApi
      IntegrationType: AWS_PROXY
      IntegrationUri: !Sub arn:aws:lambda:${AWS::Region}:${AWS::AccountId}:function:${SpaceshipsLambdaGet}
      PayloadFormatVersion: "2.0"

  SpaceshipsApiRouteGet:
    Type: AWS::ApiGatewayV2::Route
    Properties:
      ApiId: !Ref SpaceshipsApi
      RouteKey: GET /api/spaceships
      Target: !Sub integrations/${SpaceshipsApiIntegrationGet}
    DependsOn: SpaceshipsApiIntegrationGet

  SpaceshipsApiRouteGetById:
    Type: AWS::ApiGatewayV2::Route
    Properties:
      ApiId: !Ref SpaceshipsApi
      RouteKey: GET /api/spaceships/{id}
      Target: !Sub integrations/${SpaceshipsApiIntegrationGet}
    DependsOn: SpaceshipsApiIntegrationGet

  #################################################################################
  # CloudFront Distribution #######################################################
  #################################################################################

  SpaceshipsCloudFrontDistribution:
    Type: AWS::CloudFront::Distribution
    Properties:
      DistributionConfig:
        Aliases: !If
          - UseCustomDomainConfig
          - [!Ref CustomDomainName]
          - !Ref 'AWS::NoValue'
        ViewerCertificate: !If
          - UseCustomDomainConfig
          - AcmCertificateArn: !Sub 'arn:aws:acm:us-east-1:${AWS::AccountId}:certificate/${SSLCertificateId}'
            SslSupportMethod: sni-only
            MinimumProtocolVersion: TLSv1.2_2021
          - CloudFrontDefaultCertificate: true
        DefaultCacheBehavior:
          TargetOriginId: S3Origin
          ViewerProtocolPolicy: redirect-to-https
          AllowedMethods: [GET, HEAD, OPTIONS]
          CachedMethods: [GET, HEAD, OPTIONS]
          Compress: true
          CachePolicyId: 4135ea2d-6df8-44a3-9df3-4b5a84be39ad  # CachingDisabled
          OriginRequestPolicyId: 88a5eaf4-2fd4-4709-b370-b4c650ea3fcf  # CORS-S3Origin
        CacheBehaviors:
          - PathPattern: '/api/*'
            TargetOriginId: APIOrigin
            ViewerProtocolPolicy: redirect-to-https
            AllowedMethods: [DELETE, GET, HEAD, OPTIONS, PATCH, POST, PUT]
            CachedMethods: [GET, HEAD, OPTIONS]
            Compress: true
            CachePolicyId: 4135ea2d-6df8-44a3-9df3-4b5a84be39ad  # CachingDisabled
            OriginRequestPolicyId: b689b0a8-53d0-40ab-baf2-68738e2966ac  # AllViewer
            ResponseHeadersPolicyId: !Ref SpaceshipsCloudFrontHeadersPolicyApi
        DefaultRootObject: index.html
        CustomErrorResponses:
          - ErrorCode: 404
            ResponseCode: 200
            ResponsePagePath: /index.html
            ErrorCachingMinTTL: 300
          - ErrorCode: 403
            ResponseCode: 200
            ResponsePagePath: /index.html
            ErrorCachingMinTTL: 300
        Enabled: true
        HttpVersion: http2
        IPV6Enabled: true
        Origins:
          - Id: S3Origin
            DomainName: !GetAtt SpaceshipsBucketWebsite.RegionalDomainName
            S3OriginConfig:
              OriginAccessIdentity: ''
            OriginAccessControlId: !Ref SpaceshipsCloudFrontOriginAccessControl
          - Id: APIOrigin
            DomainName: !Sub '${SpaceshipsApi}.execute-api.${AWS::Region}.amazonaws.com'
            CustomOriginConfig:
              HTTPPort: 80
              HTTPSPort: 443
              OriginProtocolPolicy: https-only
              OriginSSLProtocols: [TLSv1.2]
            OriginPath: ''
        PriceClass: PriceClass_100

  SpaceshipsCloudFrontHeadersPolicyApi:
    Type: AWS::CloudFront::ResponseHeadersPolicy
    Properties:
      ResponseHeadersPolicyConfig:
        Name: SpaceshipsCloudFrontHeadersPolicyApi
        Comment: CORS policy for API behind CloudFront (conditional by DeploymentType)
        CorsConfig:
          AccessControlAllowCredentials: false
          AccessControlAllowHeaders:
            Items:
              - '*'
              - Authorization
              - Content-Type
          AccessControlAllowMethods:
            Items:
              - GET
              - HEAD
              - OPTIONS
              - POST
              - PUT
              - PATCH
              - DELETE
          AccessControlAllowOrigins:
            Items: !If
              - IsDev
              - ['*']
              - [!Sub 'https://${CustomDomainName}']
          OriginOverride: true

  SpaceshipsCloudFrontOriginAccessControl:
    Type: AWS::CloudFront::OriginAccessControl
    Properties:
      OriginAccessControlConfig:
        Name: SpaceshipsS3OriginAccessControl
        OriginAccessControlOriginType: s3
        SigningBehavior: always
        SigningProtocol: sigv4

Outputs:

  WebsiteUrl:
    Description: 'URL CloudFront'
    Value: !If
      - UseCustomDomainConfig
      - !Sub 'https://${CustomDomainName}'
      - !Sub 'https://${SpaceshipsCloudFrontDistribution.DomainName}'
    Export:
      Name: !Sub '${AWS::StackName}-WebsiteUrl'

  CloudFrontDomain:
    Description: 'CloudFront Domain Name'
    Value: !Sub '${SpaceshipsCloudFrontDistribution.DomainName}'
    Export:
      Name: !Sub '${AWS::StackName}-CloudFrontDomain'

  BucketName:
    Description: 'S3 Bucket Name for Website'
    Value: !Ref SpaceshipsBucketWebsite
    Export:
      Name: !Sub '${AWS::StackName}-BucketName'